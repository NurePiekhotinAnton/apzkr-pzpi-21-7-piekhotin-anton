РЕФЕРАТ


Пояснювальна записка до курсової роботи: 36 с., 10 рис., 2 табл., 6
додатків, 7 джерел.

СИСТЕМА СТЕЖЕННЯ, БУДИНОК, БЕЗПЕКА, СЕНСОРИ, IoT, КАМЕРИ, ДАНІ, КОНТРОЛЬ.

Об’єктом дослідження є сфера забезпечення безпеки та автоматизації житлових будинків, а саме актуальне на сьогоднішній день питання організації стеження за станом будинку з використанням сучасних технологій Інтернету речей (IoT).
Метою курсової роботи є розробка програмної системи, яка здійснює моніторинг різних параметрів будинку, таких як температура, вологість, рух, відчинення дверей та вікон, наявність диму або газу. Система має підтримувати 
інтеграцію з камерами відеоспостереження для візуального моніторингу приміщень та території навколо будинку.
Методи розробки базуються на технології Spring Boot для реалізації серверної частини, яка має мікросервісну архітектуру. Як бази даних використовується PostgreSQL. Веб-додаток розроблений на технології React, а мобільний додаток – на мові програмування Kotlin. Смарт-пристрої, такі як сенсори температури, вологості, руху, та камери відеоспостереження інтегруються в систему за допомогою відповідних API.
У результаті роботи здійснено програмну реалізацію системи стеження за станом будинку, яка включає серверну частину, веб-додаток та мобільний додаток. 


ЗМІСТ

ВСТУП	3
1 ОБ’ЄКТ РОЗРОБКИ	4
1.1	Бізнес вимоги	4
1.1.1	Передумови	4
1.1.2	Бізнес-можливості	5
1.1.3 Бізнес-цілі та критерії успіху	5
1.1.4  Потреби клієнтів або ринку	6
1.1.5 Бізнес ризики	7
1.2	Концепція рішення	7
1.2.1 Окреслення концепції	8
1.2.2 Головна функціональність	8
1.2.3 Припущення та залежності	9
1.3	Рамки та обмеження проєкту	9
1.3.1 Рамки первиного випуску	10
1.3.2 Рамки наступних випусків	10
1.3.3 Обмеження та винятки	11
1.4	Бізнес контекст	11
1.4.1 Профілі зацікавлених сторін	12
1.4.2 Пріоритети проєкту	12
1.4.3 Робоче середовище	13
2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ	15
2.1 Концептуальне моделювання предметної області	15
2.2 Інженерні рішення	17
2.2.1 Використані технології	17
2.2.2 Структура проєкту	18
2.2.3 Специфікація REST запитів	20
3 РОЗРОБКА ВЕБ ДОДАТКУ	21
3.1 Моделювання програмної системи	21
3.2 Інженерні рішення	21
3.2.1 Структура веб клієнту системи	21
3.2.2 Діяльність веб клієнту системи.	23
3.2.3 Пакети веб клієнту системи	23
3.2.4 Реалізація функції резервного копіювання	24
4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ	25
4.1 Моделювання програмної системи	25
4.2 Інженерні рішення	25
4.2.1 Структура мобільного додатку	25
4.2.2 Діяльність мобільного додатку	27
4.2.3 Пакети веб-клієнту системи	28
ВИСНОВКИ	30
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	31
ДОДАТКИ	32

 
ВСТУП


Метою роботи було створення програмної системи, що дозволяє організувати стеження за станом будинку для забезпечення його безпеки та автоматизації. Тема курсового проекту “Програмна система для організації стеження за станом будинку”. Розроблена система може використовуватись двома видами користувачів: адміністратором, який має повний доступ до всього спектру функцій системи, та звичайним користувачем, що має доступ до моніторингу стану будинку та отримання сповіщень про події.
Основне призначення програми полягало у створенні зручного додатку для роботи з даними про стан будинку, включаючи такі параметри як температура, вологість, рух, відчинення дверей та вікон, наявність диму або газу. Користувач може взаємодіяти з системою за допомогою таких реалізованих функцій: моніторинг параметрів в реальному часі, налаштування сповіщень про критичні події, перегляд відео з камер відеоспостереження. Також є можливість фільтрувати та шукати потрібну інформацію за допомогою різних критеріїв.
Розробка системи проводилася з використанням мови програмування Java на основі Spring Boot для серверної частини, яка має мікросервісну архітектуру. Бази даних зберігаються у PostgreSQL. Веб-додаток розроблений з використанням React, а мобільний додаток – на мові програмування Kotlin. Для інтеграції сенсорів та камер використовувались відповідні API.
Необхідна для реалізації проекту інформація була взята з таких ресурсів: офіційна документація Spring Boot, PostgreSQL, React та Kotlin; сайти та форуми з програмування, такі як stackoverflow.com, habr.com тощо.
 
1 ОБ’ЄКТ РОЗРОБКИ


Для розуміння об’єкту розробки було розроблено документ Vision & Scope.


1.1	Бізнес вимоги


1.1.1	Передумови


У сучасному світі все більше людей прагнуть до комфорту та безпеки у власному домі. Розвиток технологій робить можливим створення систем, які дозволяють автоматизувати багато завдань, пов'язаних з керуванням будинком. Програмні системи керування станом будинку стають все більш популярними.
Проблеми, які може вирішити наш продукт:
-	неефективне використання енергоресурсів: система може допомогти оптимізувати використання енергії, що призведе до економії коштів та зменшення впливу на довкілля;
-	недостатня безпека: система може зробити будинок більш безпечним за рахунок систем відеоспостереження, охоронної сигналізації та інших функцій;
-	незручність: система може автоматизувати багато завдань, пов'язаних з керуванням будинком, що робить життя мешканців більш комфортним;
-	відсутність контролю: система дає можливість мешканцям контролювати всі аспекти свого будинку з будь-якого місця та в будь-який час.
Програмні системи керування станом будинку є актуальним та перспективним напрямком розвитку, вони можуть вирішити багато проблем, пов'язаних з енергоефективністю, безпекою, комфортом та контролем житлового простору. 
1.1.2	Бізнес-можливості


Аналоги:
-	Samsung SmartThings: це платформа розумного будинку, яка сумісна з широким колом пристроїв від різних виробників. Її можна використовувати його для моніторингу та керування замками, нагрівачами, світлом, камерами та іншими;
-	Google Home: це платформа розумного будинку, яка працює з пристроями Google. Її можна використовувати його для моніторингу та керування своїми замками, термостатами, вогнями, камерами та іншими;
-	Fibaro: польська система розумного будинку, яка пропонує широкий спектр функцій, включаючи контроль доступу, автоматизацію та моніторинг;
-	Control4: система розумного будинку, яка використовується в основному в проектах житлового будівництва та пропонує широкий спектр функцій, включаючи автоматизацію, моніторинг та управління мультимедіа.
В проблеми перелічених продуктів можна віднести низьку сумісність з пристроями, високу ціну. Нашу систему ми створимо дешевшою та більш гнучкою для користувача.


1.1.3 Бізнес-цілі та критерії успіху


Бізнес-цілі:
-	БЦ-1: Зменшити операційні витрати на 30% протягом першого року після запуску;
-	БЦ-2: Збільшити доход на 15% протягом першого року.
Критерії успіху:
-	КУ-1: Вийти на дохід у $100 мільйонів протягом трьох років після запуску;
-	КУ-2: Досягнути рейтингу в Google Play у 4 зірки чи вище протягом шести місяців після запуску.


1.1.4  Потреби клієнтів або ринку


Типовим користувачем програмної системи є власник будинку, який шукає спосіб:
-	підвищити комфорт та зручність;
-	підвищити безпеку;
-	економити енергоресурси.
Проблеми, з якими стикаються користувачі зараз:
-	неефективне використання енергоресурсів;
-	недостатня безпека;
-	незручність керування будинком;
-	відсутність контролю.
Потреби користувачів:
-	зручність;
-	доступність;
-	надійність.
Система повинна пропонувати широкий спектр функцій, таких як:
-	моніторинг: можливість відстежувати всі аспекти будинку, такі як освітлення, температура, камери спостереження, тощо;
-	сповіщення: можливість отримувати сповіщення про важливі події, такі як підозріла активність, витік води або відключення електроенергії;
-	аналітика: можливість отримувати дані про використання енергії, безпеку та інші аспекти будинку.
Критичні інтерфейсні або функціональні вимоги:
-	інтерфейс: система повинна мати інтуїтивно зрозумілий та зручний інтерфейс, який може використовуватися людьми з різним рівнем технічної грамотності;
-	безпека: система повинна бути захищена від кібератак та інших загроз;
-	масштабованість: система має бути здатною масштабуватися, щоб відповідати потребам будинків різного розміру та складності.


1.1.5 Бізнес ризики


Основними ризиками проєкту є:
-	конкуренція: ринок подібних систем стає все більш конкурентним, і існує багато інших компаній, які пропонують подібні продукти;
-	технологічні зміни: технології розумного будинку постійно розвиваються, і наш проект може стати застарілим, якщо ми не будемо йти в ногу з останніми тенденціями;
-	фінансування: нам може не вистачити коштів для завершення проекту, інвестори можуть втратити віру в проект і припинити його фінансування;
-	розробка: розробка може бути складнішою або дорожчою, ніж очікувалося;
-	безпека: наш продукт може бути вразливим до кібератак. Витік даних може завдати шкоди нашій репутації та призвести до штрафів.


1.2	Концепція рішення


1.2.1 Окреслення концепції


Ми уявляємо світ, де кожен будинок є розумним, комфортним, безпечним та економним. Наша система перетворить спосіб, яким люди живуть у своїх будинках, зробивши їх більш комфортними, безпечними та економними. Наша система дасть людям можливість:
-	контролювати всі аспекти свого будинку з будь-якого місця та в будь-який час: освітлення, температуру, камери спостереження, тощо;
-	отримувати сповіщення про важливі події: система може сповіщати вас про підозрілу активність, витік води, відключення електроенергії та інші події;
-	економити енергоресурси: система може допомогти вам оптимізувати використання енергії, економлячи ваші кошти та зменшуючи ваш вплив на довкілля.
Ми прагнемо зробити наш продукт доступним для людей з різним бюджетом, щоб кожен міг жити в розумному, комфортному, безпечному та економному будинку. Ми віримо, що наш продукт має потенціал змінити світ на краще.


1.2.2 Головна функціональність


MF-1: Реєстрація та авторизація користувачів.
MF-2: Моніторинг та контроль будинку.
-	освітлення: контроль освітленності приміщення;
-	температура: контроль температури в приміщеннях;
-	камери спостереження: віддалений перегляд камер, отримання сповіщень про підозрілу активність.
MF-3: Отримання сповіщень про важливі події:
-	сповіщення про відключення електроенергії: система може сповіщати вас про відключення електроенергії, щоб ви могли бути до цього готові;
-	інші сповіщення: можливість налаштування інших сповіщень за вашими потребами.
MF-4: Веб-інтерфейс: реалізація панелі адміністратора для керування додатком.


1.2.3 Припущення та залежності


Припущення:
-	користувачі мають доступ до смартфона або комп'ютера з підключенням до Інтернету;
-	користувачі мають базові знання про використання мобільних додатків або веб-інтерфейсів;
-	будинок користувача має електричну проводку та доступ до Wi-Fi;
-	всі пристрої розумного будинку, які хочеться використовувати з нашою системою є сумісні з нею.
Залежності:
-	функціонування системи залежить від безперебійної роботи Інтернет-з'єднання;
-	система залежить від наявності та працездатності сумісних пристроїв розумного будинку;
-	ефективність залежить від правильної установки та налаштування всіх компонентів системи.


1.3	Рамки та обмеження проєкту


1.3.1 Рамки первиного випуску

Веб-застосунок:
-	Панель адміністратора для керування додатком.
Мобільний додаток:
-	реєстрація та авторизація: користувачі зможуть створити обліковий запис та увійти в систему, щоб отримати доступ до функцій програми;
-	моніторинг та контроль: користувачі зможуть відстежувати та керувати всіма аспектами свого будинку з мобільного пристрою;
-	сповіщення: користувачі зможуть отримувати сповіщення про важливі події;
-	налаштування: користувачі зможуть налаштувати параметри системи відповідно до своїх потреб, як описано в розділі 2.1.
Функціональні можливості першого випуску:
MF-1: Реєстрація та авторизація
MF-2: Моніторинг та контроль
MF-4: Дистанційне керування


1.3.2 Рамки наступних випусків


Після успішного запуску першого випуску ми плануємо розширити функціональність у наступних випусках.
Ось деякі з можливих функцій, які можуть бути включені в наступні випуски:
-	підтримка нових пристроїв розумного будинку: програма буде розширена для підтримки ширшого спектру пристроїв розумного будинку від різних виробників;
-	можливості аналітики: система буде пропонувати аналітичні дані, такі як прогнозування використання енергії, виявлення аномалій та рекомендації щодо економії енергії;
-	функції штучного інтелекту: система буде використовувати штучний інтелект для автоматизації завдань, персоналізації досвіду користувачів та прогнозування потреб користувачів;
-	підтримка голосових команд: система буде підтримувати голосові команди, що дозволить користувачам керувати своїм будинком за допомогою голосу;
Також ми будемо постійно збирати відгуки користувачів та використовувати їх для вдосконалення продукту та розробки нових функцій.


1.3.3 Обмеження та винятки


Залежність від інфраструктури:
-	електроенергія: система потребує безперебійного живлення для роботи. У разі відключення електроенергії система не буде функціонувати;
-	Інтернет: система використовує Інтернет для зв'язку з пристроями розумного будинку, мобільним додатком та веб-інтерфейсом. Відсутність підключення до Інтернету обмежить або унеможливить роботу.
Технічні обмеження:
-	точність: дані, що збираються датчиками, можуть мати певну похибку;
безпека: система використовує заходи для захисту даних, але жодна система не є абсолютно безпечною.


1.4	Бізнес контекст 


1.4.1 Профілі зацікавлених сторін 

Табл. 1 – профілі зацікавлених сторін
Stakeholder	Major Value	Attitudes	Major Interests	Constraints
Власники будинків	Збільшення комфорту, безпеки, економії енергії, економії коштів	В цілому позитивне, але може викликати занепокоєння вартість впровадження та використання системи	Можливість керувати своїм будинком з будь-якого місця, отримувати сповіщення про важливі події, економити енергію	Повинна бути простою у використанні, сумісною з існуючими пристроями та доступною за ціною
Орендарі	Збільшення комфорту, безпеки, економії енергії	В цілому позитивне, але може викликати занепокоєння втрата контролю над своїм будинком	Можливість керувати своїм будинком з будь-якого місця, отримувати сповіщення про важливі події	Повинна бути простою у використанні, не нав'язувати небажані функції


1.4.2 Пріоритети проєкту 

	Табл. 2 – приорітети проєкту
Dimension	Driver	Constraint
(state limits)	Constraint
Терміни	Реліз 1.0 має бути доступний до 20/05, реліз 1.1 до 05/06	Необхідно відповідати мінімальним вимогам до персоналу	Можна скоригувати обсяг і функції, щоб дотриматися термінів
Функції	70-80% функцій високого пріоритету повинні бути включені до релізу 1.0	Необхідно відповідати мінімальним вимогам до якості	Можна скоригувати терміни та бюджет, щоб додати додаткові функції
Якість	90-95% тестів на прийняття користувачами повинні бути пройдені для релізу 1.0, 95-98% для релізу 1.1	Необхідно відповідати мінімальним обмеженням за термінами та бюджетом	Можна скоригувати функції та обсяг, щоб відповідати вимогам до якості
Персонал	Максимальний розмір команди – 1 розробник	Повинен мати достатні навички та досвід	Можна скоригувати терміни та бюджет, щоб додати додатковий персонал
Вартість	Перевищення бюджету до 15% допустиме без розгляду керівництвом	Необхідно відповідати мінімальним вимогам до якості та функцій	Можна скоригувати терміни та персонал, щоб відповідати бюджетним обмеженням


1.4.3 Робоче середовище 


Додаток буде розроблений з використанням наступних технологій та програмних інструментів:
-	фронтенд-розробка: React;
-	бекенд-розробка: Java, Spring;
-	база даних: PostgreSQL;
-	мобільний додаток: Kotlin;
-	тестування: Junit, Mockito;
-	розгортання: Microsoft Azure.
Для розробки IoT частини продукту буде використовуватися Arduino у Wokwi емуляторі. Середою розробки буде Arduino IDE. Прилад буде обраховувати температуру повітря, вологу, освітленість приміщення.
Для розробки мобільного застосунку буде використовуватися Kotlin та Android Studio
 
2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ
2.1 Концептуальне моделювання предметної області


Для реалізації визначеного функціоналу треба перш за все чітко визначити та описати всі необхідні сутності системи. В цьому допоможе розробка ER-моделі даних, яка візуалізує всі сутності ті зв’язки між ними. Після визначення сутностей можна буде створити ER-модель даних. 
Модель даних включає в себе наступні сутності та поля:
а) користувач:
1)	іd користувача;
2)	пароль;
3)	електронна пошта;
4)	роль;
5)	ім’я;
6)	статус акаунта;
7)	дата реєстрації;
	б) будинок:
1)	id будинку;
2)	власник id;
3)	назва;
4)	адреса;
	в) девайс:
1)	id девайсу;
2)	id будинку до якого підключений;
3)	тип девайсу.
г) ролі:
	1) id ролі;
	2) назва.
Тепер, коли всі сутності та поля, що їм належать визначенні, розглянемо сценарії використання системи. Увесь функціонал зазначений у документі Vision & Scope був розподілений між двома акторами, а саме: користувач-клієнт системи та адміністратор. Користувач може увійти до системи за допомогою мобільного додатку. Зареєструвавшись та авторизувавшись він отримує доступ до функціоналу цієї ролі (див. Додаток А). Він може переглядати свої будинки та девайси. Створювати нові, редагувати наявні. Також може переглядати інформацію отриману з датчиків-девайсів для контролю станом будинку. Адміністратор має можливість переглядати інформацію про всіх користувачів системи, змінювати їх ролі блокувати та видаляти їх, також має змогу експортувати дані з бази даних до csv-файлу (див. Додаток Б). 
 На основі таких сценаріїв використання системи була створена UML діаграма прецедентів (див. рис. 2.1).
 
Рисунок 2.1 - UML діаграма прецедентів.
Також, після визначення сутностей та зв’язків між ними було створено ER-діаграму (див. рис. 2.2).
 
Рисунок 2.2 - ER модель даних

Таким чином, в результаті концептуального моделювання предметної області, були визначені основні сутності програмної системи та створені дві діаграми. Далі ми розглянемо прийняті інженерні рішення.


2.2 Інженерні рішення 


2.2.1 Використані технології 


Технології, використані для розробки серверної частини, були обрані з урахуванням функціональних вимог проекту. Для написання серверної частини була обрана мова програмування Java та фреймворк Spring Boot. Spring Boot надає зручний і швидкий спосіб створення веб-додатків, маючи рішення для вирішення всіх проблем нашого проєкту. Для реалізації мікросервісної архітектури було створено такі модулі як api-gateway фреймворку spring-cloud-gateway, для обробки всіх запитів користувачів та переспрямування їх до відповідного сервісу. Auth-service та 3 сервіси, які відповідають за бізнес логіку. Як бази даних використовується СКБД PostgreSQL, які запускаються окремо як контейнери Docker, отже кожний сервіс має свою базу даних, що відповідає архітектурі мікросервісних додатків. Ці бази даних забезпечують надійне зберігання даних, а фреймворк Spring Data JPA надає функціонал для зручного спілкування з ними. Всі сервіси системи реалізовані з використанням Spring Boot, що дозволяє легко і швидко розробляти та підтримувати серверну частину. Також для тестування системи використовуються такі фреймворки як JUnit та Mockito, що дозволяють швидко та зручно протестувати написаний функціонал. Окрім цього, спілкування між сервером та клієнтською частиною, а також із мобільним додатком, реалізоване за допомогою HTTP запитів, що забезпечує незалежність кожної частини системи та формує загальну структуру взаємодії системи. 
Додатково можна відмітити реалізацію комунікації між сервісами за допомогою http запитів (див. Додаток В).


2.2.2 Структура проєкту


Система має мікросервісну структуру проєкту Spring Boot, яка складається з наступних модулів:
-	api-gateway;
-	auth-service;
-	house-service;
-	user-service;
-	device-service.
Більш детальна інформація системи представлена на UML-діаграмі розгортання (див. рис. 2.3)
 
Рисунок 2.3 – UML діаграма розгортання.


Також було створено базову UML-діаграму пакетів для сервісів (див. рис.2.4). За цим шаблоном були створені всі сервіси системи.


 
Рисунок 2.4 – UML діаграма пакетів.


2.2.3 Специфікація REST запитів


Була створена таблиця-специфікація HTTP запитів усіх методів системи (див. Додаток Г).


 
3 РОЗРОБКА ВЕБ ДОДАТКУ
	3.1 Моделювання програмної системи


	Системою користуються адміністратори системи. За допомогою веб-клієнту, вони можуть авторизуватися у систему, переглядати інформацію про всі сутності системи. Також адміністратор може редагувати інформацію про всі сутності системи. Для демонстрації вище означених сценаріїв була створена UML діаграма прецедентів (див. рис. 3.1).
 
Рисунок 3.1 - UML діаграма прецедентів веб-клієнту системи


3.2 Інженерні рішення


3.2.1 Структура веб клієнту системи 


Front-End частина проєкту створена за допомогою бібліотеки React. Проєкт має стандартну структуру React-додатків. Розглянемо її детальніше.
Для демонстрації структури клієнтської частини проекту була створена діаграма компонентів з яких вона складається (див. рис. 3.2). На ній відображені всі компоненти системи. 
 
Рисунок 3.2 - UML діаграма компонентів веб-клієнту системи

Вхідною точкою додатку є файл index.js, котрий посилається на файл App.js, в якому описується основна логіка додатку. Код файлу наведено в додатку Д. В цьому файлі можемо побачити реалізацію шляхів, які описані у файлі router\index.js. Також можемо побачити перевірку аутентифікації користувача, збірігання ролі.
За авторизацію у систему відповідає компонент SignIn. Його код наведено у додатку Е. В ньому можна побачити запит на сервер для авторизації, збереження даних авторизованого користувача, таких як id, роль та Bearer токен, для створення подальших запитів.
За відображення даних сутностей відповідають такі компоненти як Houses, Devices, Users. Для отримання інформації з бекенд серверу використовується бібліотека Axios, приклад коду запиту до серверної частини наведено у додатку А.3. В кожному запиті передається токен авторизації, в іншому випадку запит не буде опрацьований на сервері


	3.2.2 Діяльність веб клієнту системи.


Для демонстрації усіх можливих дій для користувача була розроблена діаграма діяльності (див. рис. 3.3).
 
Рисунок 3.3 - UML діаграма діяльності веб-клієнту системи

На даній діаграмі детально відображено дії, які доступні користувачеві та етапи, через які необхідно пройти, що їх здійснити.
	3.2.3 Пакети веб клієнту системи


	Для демонстрації каталогів системи була розроблена діаграма пакетів (див. рис. 3.4). На неї відображено усі основні пакети, які має система та їх залежність один від одного. 
 
Рисунок 3.4 – UML діаграма пакетів.


	3.2.4 Реалізація функції резервного копіювання


	Система має функцію створення резервної копії бази даних. Відправляється запит на серверну частину системи та після цього створюється резервна копія даних користувачів на комп’ютері адміністратора. Код для цієї функції наведений у Додатку Б.

4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ
	4.1 Моделювання програмної системи


	Системою користуються клієнти системи. За допомогою додатку, вони можуть авторизуватися у систему, переглядати та редагувати інформацію в своєму профілі, переглядати та керувати своїми будинками та девайсами в них. Для демонстрації вище означених сценаріїв була створена UML діаграма прецедентів (див. рис. 4.1).
 
Рисунок 4.1 - UML діаграма прецедентів мобільного застосунку


4.2 Інженерні рішення 


4.2.1 Структура мобільного додатку


Mobile частина проєкту створена за допомогою мови програмування Kotlin. Проєкт має стандартну структуру Kotlin-додатків, з використаннням класів Activity та файлів View. Розглянемо її детальніше.
Для демонстрації структури клієнтської частини проекту була створена діаграма компонентів з яких вона складається (див. рис. 4.2). На ній відображені всі компоненти системи. 

 
Рисунок 4.2 - UML діаграма компонентів мобільного додатку
 
За відображення даних відповідають файли View, які мають формат xml. В них створюється шаблон сторінки для відображення користувачу, зокрема створення об’єктів для взаємодії, таких як кнопки чи ввідні поля. В свою чергу класи Activity наповнюють ці шаблони потрібною інформацією, створюють обробники для об’єктів та керують іншою сторонньою логікою, яка потрібна для користувача.
Вхідною точкою додатку є MainActivity, на якій користувач обирає подальший шлях: реєстрація або авторизація. 
За реєстрацію та авторизацію у систему відповідає сервіс AuthService. Код методу login() можна побачити в Додатку A.1. В ньому можна побачити створення http-запиту за допомогою okHttp3 та Gson, відправку запиту, та отримання відповіді від бекенд серверу.
За зберігання глобальної інформації про користувача, такої як його ідентифікатор та токен, отриманий при авторизації відповідає клас TokenStorageService. Його код наведений у додатку А.2. 
Для відправки запитів на бекенд сервер використовуються класи сервіси в директорії service, для обробки запитів по сутності будинки – HouseService, для девайсів – відповідно DeviceService. Приклад коду створення http-запиту, наповнення його потрібною інформацією та відправкою на бекенд сервер, наведено в додатку Б.1
Для отримання та коректного відображення списків об’єктів отриманих з серверу було створено класи адаптери в директорії adapter. Приклад коду HouseAdapter наведено в додатку Б.2


4.2.2 Діяльність мобільного додатку


Для демонстрації усіх можливих дій для користувача була розроблена діаграма діяльності (див. рис. 4.3).

 
Рисунок 4.3 - UML діаграма діяльності мобільного додатку

На даній діаграмі детально відображено дії, які доступні користувачеві та етапи, через які необхідно пройти, що їх здійснити.


4.2.3 Пакети веб-клієнту системи


Для демонстрації каталогів системи була розроблена діаграма пакетів (див. рис. 4.4). На неї відображено усі основні пакети, які має система та їх залежність один від одного.

 
Рисунок 4.4 – UML діаграма пакетів.
 
ВИСНОВКИ


Під час виконання проєкту було реалізовано програмну систему на тему «Програмна система для організації стеження за станом будинку». В процесі створення було вивчено багато нових тем, прийомів та принципів програмування застосунків такого типу, також покращені навички проєктування та реалізації систем з мікросервісною архітектурою. Покращено знання мови Java, набуто цінного досвіду та навичок, зокрема були закріплені знання з програмування на платформі Spring Boot та Spring Cloud. Розроблена система є високо масштабованою, що звичайно є великим плюсом.
Веб-додаток розроблено з використанням React, що дозволило поглибити знання в області frontend-розробки. 
Мобільний додаток створено на мові Kotlin, що сприяло набуттю досвіду розробки мобільних застосунків.
Розроблена система дозволяє здійснювати моніторинг та управління станом будинку, має функції стеження за станом будинку.
	Програмний код було розміщено на платформі GitHub в публічному репозиторії.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Мартін Р. Чистий код: Створення, аналіз і рефакторинг [Текст] / Роберт Мартін. -Київ: Діалектика, 2010. -464 с.
2.	Фаулер М. Рефакторинг: покращення існуючого коду [Текст] / Мартін Фаулер. -Київ: Діалектика, 2019. -448 с.
3.	Документація Spring Boot. URL: https://spring.io/projects/spring-boot
4.	Документація React. URL: https://react.dev/learn
5.	Документація Kotlin. URL: https://kotlinlang.org/docs/home.html
6.	Посилання на репозиторій GitHub. URL: https://github.com/NurePiekhotinAnton/apzkr-pzpi-21-7-piekhotin-anton
7.	Посилання на відеоролик на YouTube. URL:  https://www.youtube.com/watch?v=tTv4k6XpDMY


 
ДОДАТКИ
ДОДАТОК А. Код класу авторизації та реєстрації

1 @Component
2 @Slf4j
3 @RequiredArgsConstructor
4 public class GuestAuthenticationManager {
5 	private final AuthenticationManager authenticationManager;
6 	private final JwtUtil jwtUtil;
7	//Успішна аутентифікація, збереження її до Spring Security контексту та повертання jwt токену
8 	public Authentication authenticateRequest(AuthRequestDto requestDto) {
9 		return authenticationManager.authenticate(
10 			new UsernamePasswordAuthenticationToken(requestDto.getEmail(), requestDto.getPassword()));
11 		}
12
13 	public JwtResponseDto handlingSuccessfulAuthentication (Authentication auth) {
14 		UserDetailsImpl userDetails = (UserDetailsImpl) auth.getPrincipal();
15 		UsernamePasswordAuthenticationToken authToken =
16 		new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
17 	SecurityContextHolder.getContext().setAuthentication(authToken);
18
19 	String jwt = jwtUtil.generateToken(userDetails);
20 	String role = userDetails.getAuthorities().stream()
21 	.map(GrantedAuthority::getAuthority).findFirst().orElse("");
22
23 	return JwtResponseDto.builder()
24 	.token(jwt)
25 .expiresAt(convertToLocalDateViaInstant(jwtUtil.extractExpiration(jwt)))
26 	.type("Bearer")
27 	.guestId(userDetails.getId())
28 	.email(userDetails.getUsername())
29 	.role(role)
30 	.build();
31 	}
32	//Приведення до локального часу користувача.
33    private LocalDate convertToLocalDateViaInstant(Date dateToConvert){
34 		return dateToConvert.toInstant()
35 		.atZone(ZoneId.systemDefault())
36 		.toLocalDate();
37 	}
38
39 }

 
ДОДАТОК Б. Код експорту даних користувачів з БД
1 /**
2  * Код експорту даних користувачів.
3  */
4 public String exportUsers() {
5     List<Guest> users = getAllUsers();
6     //Створення папки
7     File directory = new File("C:\\SafeHouse");
8     if (!directory.exists()) {
9         directory.mkdirs();
10    }
11    //Створення файлу
12    File csvFile = new File("C:\\SafeHouse\\users.csv");
13    try (FileWriter writer = new FileWriter(csvFile)) {
15        writer.write("id,email,name,password,isEnabled,roles,creationDate\n");
16        for (Guest user : users) {
17            //Запис даних кожного користувача
18            writer.write(String.format("%d,%s,%s,%s,%s,%s,%s\n",
19                user.getId(),
20                user.getEmail(),
21                user.getName(),
22                user.getPassword(),
23                user.getIsEnabled(),
24                user.getRole(),
25                user.getCreated()));
26        }
27        return "Successful export users to file users.csv";
28    } catch (IOException e) {
29        e.printStackTrace();
30        return "Export failed";
31    }
32 }
ДОДАТОК В. Виклик REST запиту до іншого сервісу

1 public List<DeviceDto> getHouseDevices(Long houseId) {
2 	if (houseId == null || houseId <= 0)
3 		return null;
4
5 	ResponseEntity<List<DeviceDto>> response restTemplate.exchange
("http://localhost:8083/api/v1/device/my/" + houseId,
6 		HttpMethod.GET,
7 		null,
8 		new ParameterizedTypeReference<>() {
9 	}
10	);
11 	return response.getBody();
12}
 
ДОДАТОК Г. Специфікація REST API

Таблиця В.1 - Специфікація REST API серверної частини системи
Контролер 	Метод	Посилання	Дія
Auth-contoller	POST	auth/sign-up	Реєстрація.
	POST	auth/sign-in	Авторизація.
	GET	auth/export-users	Експорт даних користувачів до окремого файлу.
	GET	auth/user/{userId}	Отримати інформацію про користувача.
	POST	auth/edit-user/{id} 
@RequestBody	Редагувати користувача.
	GET	auth/users	Отримати список всіх користувачів.
	POST	auth/backup	Створення бекапу бази даних користувачів.
User-controller	POST	user/edit/{id}
@RequestBody	Редагувати користувача.
	GET	user/{id}	Отримати інформацію про користувача.
House-controller	GET	/house/{id}	Отримати інформацію про будинок.
	POST	/create/{id}
@RequestBody	Створити будинок.
	POST	/house/delete/{id}	Видалити будинок.
	GET	/house/my/{userId}	Отримати всі будинки користувача.
	GET	/house/devices/{houseId}	Отримати всі девайси будинку.
	GET	/house/all	Отримати всі будинки.
Device-controller	GET	/device/{id}	Отримати інформацію про девайс.
	POST	/device/delete/{id}	Видалити девайс.
	POST	/device/create/{houseId}	Створити девайс.
	GET	/device/my/{houseId}	Отримати список девайсів в наданому будинку.
	GET	/device/info/{deviceId}	Відправити запит на отримання інформації зі смарт-девайсу.
	GET	/device/all	

 
ДОДАТОК Д. Код файлу App.js
1  import React, {useEffect, useState} from 'react'
2  import {BrowserRouter as Router, Route, Routes} from 'react-router-dom'
3  import {AuthContext} from './сontext'
4  import Navbar from './components/Navbar'
5  import './styles/App.css'
6  import {adminRoutes, publicRoutes} from './router'
7  
8  function App() {
9      // Створення змінних для авторизації
10     const [userId, setUserId] = useState(null)
11     const [isAuth, setIsAuth] = useState(false)
12     const [userRole, setUserRole] = useState("ROLE_USER")
13 
14     // Перевірка чи користувач авторизований
15     useEffect(() => {
16         if (localStorage.getItem('auth')) {
17             setIsAuth(true)
18         }
19         if (localStorage.getItem('role') === "ADMIN") {
20             setUserRole("ROLE_ADMIN")
21         }
22     }, [])
23 
24     return (
25         <AuthContext.Provider value={{isAuth, setIsAuth, userId, setUserId, userRole, setUserRole}}>
26             <Router>
27                 <Navbar></Navbar>
28                 {isAuth
29                     ?
30                     <Routes>
31                         {publicRoutes.map(route =>
32                             <Route
33                                 Component={route.component}
34                                 path={route.path}
35                                 exact={route.exact}
36                             ></Route>
37                         )}
38                         {userRole === "ROLE_ADMIN"
39                             ? adminRoutes.map(route =>
40                                 <Route
41                                     Component={route.component}
42                                     path={route.path}
43                                     exact={route.exact}
44                                 ></Route>
45                             )
46                             : null
47                         }
48                     </Routes>
49                     :
50                     <Routes>
51                         {publicRoutes.map(route =>
52                             <Route
53                                 Component={route.component}
54                                 path={route.path}
55                                 exact={route.exact}
56                             ></Route>
57                         )}
58                     </Routes>}
59 
60             </Router>
61         </AuthContext.Provider>
62     )
63 }
64 
65 export default App
 
ДОДАТОК Е. Код компоненту SignIn
1  import React, {useContext, useState} from 'react'
2  import axios from 'axios'
3  import {useNavigate} from 'react-router-dom'
4  import {AuthContext} from '../сontext'
5  
6  function SignIn() {
7      const {isAuth, setIsAuth} = useContext(AuthContext)
8      const navigate = useNavigate()
9      const [user, setUser] = useState({email: '', password: ''})
10     const {userRole, setUserRole} = useContext(AuthContext)
11     const [errorMessage, setErrorMessage] = useState("")
12 
13     async function signIn(e) {
14         e.preventDefault()
15 
16         // Перевірка на валідність даних
17         if (user.email != '' && user.password != '') {
18             try {
19                 // Запит на сервер для авторизації
20                 let response = await axios.post('https://localhost:8080/api/v1/auth/sign-in', user)
21                 if (response.data == null || response.data == '') {
22                     console.log("empty response")
23                     return
24                 }
25                 // Перевірка ролі користувача
26                 if (response.data.role === 'CLIENT') {
27                     setErrorMessage("You are not an admin")
28                     console.log("client")
29                     return
30                 }
31                 // Збереження даних в localStorage
32                 localStorage.setItem('auth', 'true')
33                 localStorage.setItem('token', response.data.token)
34                 localStorage.setItem('role', response.data.role)
35                 localStorage.setItem('id', response.data.guestId)
36                 setUserRole('ROLE_ADMIN')
37                 setIsAuth(true)
38 
39                 console.log('auth: ' + localStorage.getItem('auth'))
40                 console.log("successful sign in")
41                 navigate('/')
42             } catch (err) {
43                 console.log(err)
44             }
45         } else {
46             console.log("invalid data")
47             setErrorMessage("Invalid data")
48         }
49     }
50 
51     return (
52         <>
53             <form className='w-25 mt-5'>
54                 <div class="mb-3">
55                     <label for="exampleInputEmail1" class="form-label">Email:</label>
56                     <input type="email" className="form-control" id="exampleInputEmail1" aria-describedby="emailHelp"
57                            value={user.email} onChange={e => setUser({...user, email: e.target.value})}></input>
58                 </div>
59                 <div class="mb-3">
60                     <label for="exampleInputPassword1" class="form-label">Password:</label>
61                     <input type="password" className="form-control" id="exampleInputPassword1" value={user.password}
62                            onChange={e => setUser({...user, password: e.target.value})}></input>
63                 </div>
64                 <button type="submit" className="btn btn-primary " onClick={signIn}>LogIn</button>
65                 <div className='text-danger'>{errorMessage}</div>
66             </form>
67         </>
68     )
69 }
70 
71 export default SignIn
